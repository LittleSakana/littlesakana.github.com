<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.6">Jekyll</generator><link href="/atom.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2016-12-30T17:09:53+08:00</updated><id>/</id><title>LittleSakana Development</title><subtitle>开发学习过程笔记及开发经验积累，以供参考</subtitle><entry><title>JavaScript Memo (三)</title><link href="/javascript/JavaScriptMemo3/" rel="alternate" type="text/html" title="JavaScript Memo (三)" /><published>2016-11-12T00:00:00+08:00</published><updated>2016-11-12T00:00:00+08:00</updated><id>/javascript/JavaScriptMemo3</id><content type="html" xml:base="/javascript/JavaScriptMemo3/">&lt;blockquote&gt;
  &lt;p&gt;现在让我们看看函数和方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;函数&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;定义函数&lt;/h3&gt;

&lt;p&gt;JavaScript的函数也是一个对象，下面定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function abs(x) {
    if (x &amp;gt;= 0) {
        return x;
    } else {
        return -x;
    }
}
function指出这是一个函数定义;
abs是函数的名称;
(x)括号内列出函数的参数，多个参数以,分隔;
{ ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;调用函数&lt;/h3&gt;

&lt;p&gt;JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abs(10, &#39;blablabla&#39;); // 返回10
abs(-9, &#39;haha&#39;, &#39;hehe&#39;, null); // 返回9
abs(); // 返回NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数,利用arguments，你可以获得调用者传入的所有参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function abs() {
    if (arguments.length === 0) {
        return 0;
    }
    var x = arguments[0];
    return x &amp;gt;= 0 ? x : -x;
}

abs(); // 0
abs(10); // 10
abs(-9); // 9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;变量作用域&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量&lt;/li&gt;
  &lt;li&gt;JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&#39;use strict&#39;;

function foo() {
    var x = 1;
    function bar() {
        var x = &#39;A&#39;;
        alert(&#39;x in bar() = &#39; + x); // &#39;A&#39;
    }
    alert(&#39;x in foo() = &#39; + x); // 1
    bar();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo() {
    var x = &#39;Hello, &#39; + y;
    alert(x);
    var y = &#39;Bob&#39;;
}

//提升后相当于
function foo() {
    var y; // 提升变量y的申明
    var x = &#39;Hello, &#39; + y;
    alert(x);
    y = &#39;Bob&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;语句var x = ‘Hello, ‘ + y;并不报错，原因是变量y在稍后申明了。但是alert显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;全局作用域&lt;/h3&gt;

&lt;p&gt;不在任何函数内定义的变量就具有全局作用域，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var course = &#39;Learn JavaScript&#39;;
alert(course); // &#39;Learn JavaScript&#39;
alert(window.course); // &#39;Learn JavaScript&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-5&quot;&gt;命名空间&lt;/h3&gt;

&lt;p&gt;全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突；减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = &#39;myapp&#39;;
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return &#39;foo&#39;;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;常量&lt;/h3&gt;

&lt;p&gt;var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，ES6标准引入了新的关键字const来定义常量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;方法&lt;/h2&gt;

&lt;p&gt;绑定到对象上的函数称为方法，它在内部使用了一个this关键字，this是一个特殊变量，它始终指向当前对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: &#39;小明&#39;,
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25, 正常结果
getAge(); // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-8&quot;&gt;高阶函数&lt;/h2&gt;

&lt;p&gt;JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function add(x, y, f) {
    return f(x) + f(y);
}
add(-5, 6, Math.abs);//11
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;map&quot;&gt;map函数&lt;/h3&gt;

&lt;p&gt;调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function pow(x) {
    return x * x;
}

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reduce&quot;&gt;reduce函数&lt;/h3&gt;

&lt;p&gt;reduce()把一个函数作用在Array的[x1, x2, x3…]上，把结果继续和序列的下一个元素做累积计算&lt;code class=&quot;highlighter-rouge&quot;&gt;[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25

要把[1, 3, 5, 7, 9]变换成整数13579
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter函数&lt;/h3&gt;

&lt;p&gt;用于是把Array的某些元素过滤掉，然后返回剩下的元素。&lt;/p&gt;

&lt;p&gt;Array的filter()接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在一个Array中，删掉偶数，只保留奇数
var arr = [1, 2, 4, 5, 6, 9, 10, 15];
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]

//去除Array的重复元素
var r,arr = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;strawberry&#39;];
r = arr.filter(function (element, index, self) {
    return self.indexOf(element) === index;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sort&quot;&gt;sort函数&lt;/h3&gt;

&lt;p&gt;sort()方法默认把所有元素先转换为String再排序。sort()方法会直接对Array进行修改，它返回的结果仍是当前Array。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&#39;Google&#39;, &#39;Apple&#39;, &#39;Microsoft&#39;].sort(); // [&#39;Apple&#39;, &#39;Google&#39;, &#39;Microsoft&#39;];

[&#39;Google&#39;, &#39;apple&#39;, &#39;Microsoft&#39;].sort(); // [&#39;Google&#39;, &#39;Microsoft&quot;, &#39;apple&#39;]

[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x &amp;lt; y) {
        return -1;
    }
    if (x &amp;gt; y) {
        return 1;
    }
    return 0;
}); // [1, 2, 10, 20]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;arrow-function&quot;&gt;Arrow Function&lt;/h2&gt;

&lt;p&gt;ES6标准新增了一种新的函数：Arrow Function（箭头函数）它的定义用的就是一个箭头&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x =&amp;gt; x * x
相当于
function (x) {
    return x * x;
}

// 两个参数:
(x, y) =&amp;gt; x * x + y * y

// 无参数:
() =&amp;gt; 3.14

// 可变参数:
(x, y, ...rest) =&amp;gt; {
    var i, sum = x + y;
    for (i=0; i&amp;lt;rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary>现在让我们看看函数和方法</summary></entry><entry><title>JavaScript Memo (二)</title><link href="/javascript/JavaScriptMemo2/" rel="alternate" type="text/html" title="JavaScript Memo (二)" /><published>2016-11-05T00:00:00+08:00</published><updated>2016-11-05T00:00:00+08:00</updated><id>/javascript/JavaScriptMemo2</id><content type="html" xml:base="/javascript/JavaScriptMemo2/">&lt;blockquote&gt;
  &lt;p&gt;基本语法中的条件判断和循环。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;if-else&quot;&gt;条件判断if-else&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;不解释，只有一点注意，JavaScript把null、undefined、0、NaN和空字符串’‘视为false，其他值一概视为true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var age = 3;
if (age &amp;gt;= 18) {
    alert(&#39;adult&#39;);
} else if (age &amp;gt;= 6) {
    alert(&#39;teenager&#39;);
} else {
    alert(&#39;kid&#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;for&quot;&gt;for循环&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;for循环最常用的地方是利用索引来遍历数组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [&#39;Apple&#39;, &#39;Google&#39;, &#39;Microsoft&#39;];
var i, x;
for (i=0; i&amp;lt;arr.length; i++) {
    x = arr[i];
    alert(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;for循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var o = {
    name: &#39;Jack&#39;,
    age: 20,
    city: &#39;Beijing&#39;
};
for (var key in o) {
    alert(key); // &#39;name&#39;, &#39;age&#39;, &#39;city&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;for--in&quot;&gt;for … in&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称,一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
a.name = &#39;Hello&#39;;
for (var x in a) {
    alert(x); // &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;name&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;for--of&quot;&gt;for … of&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型&lt;/p&gt;

  &lt;p&gt;具有iterable类型的集合可以通过新的for … of循环来遍历&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
var s = new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);
var m = new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);
for (var x of a) { // 遍历Array
    alert(x);// &#39;A&#39;, &#39;B&#39;, &#39;C&#39;
}
for (var x of s) { // 遍历Set
    alert(x);
}
for (var x of m) { // 遍历Map
    alert(x[0] + &#39;=&#39; + x[1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;foreach&quot;&gt;forEach()&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;ES5.1标准引入forEach()方法&lt;/p&gt;

  &lt;p&gt;它接收一个函数，每次迭代就自动回调该函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    alert(element);
});

var s = new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);
s.forEach(function (element, sameElement, set) {
    alert(element);
});

var m = new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);
m.forEach(function (value, key, map) {
    alert(value);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary>基本语法中的条件判断和循环</summary></entry><entry><title>JavaScript Memo (一)</title><link href="/javascript/JavaScriptMemo/" rel="alternate" type="text/html" title="JavaScript Memo (一)" /><published>2016-10-29T00:00:00+08:00</published><updated>2016-10-29T00:00:00+08:00</updated><id>/javascript/JavaScriptMemo</id><content type="html" xml:base="/javascript/JavaScriptMemo/">&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;JavaScript是一种运行在浏览器中的解释型的编程语言。&lt;/strong&gt;
&amp;gt;1995年，网景公司的Brendan Eich在两周之内设计出了JavaScript语言。&lt;/p&gt;

&lt;h4 id=&quot;ecmascript&quot;&gt;ECMAScript&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;最新版ECMAScript 6标准（简称ES6）已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本语法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;语句以;结束&lt;/li&gt;
  &lt;li&gt;语句块用{…}&lt;/li&gt;
  &lt;li&gt;以//开头直到行末的字符被视为行注释&lt;/li&gt;
  &lt;li&gt;块注释是用/*…*/把多行字符包裹起来&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;数据类型&lt;/h3&gt;

&lt;h3 id=&quot;number&quot;&gt;Number&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Number四则运算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 + 2; // 3
(1 + 2) * 5 / 2; // 7.5
2 / 0; // Infinity
0 / 0; // NaN
10 % 3; // 1
10.5 % 3; // 1.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;字符串&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。&lt;/p&gt;

  &lt;p&gt;转义字符\可以转义很多字符，\n表示换行，\t表示制表符，字符\本身也要转义，\\表示的字符就是\&lt;/p&gt;

  &lt;p&gt;ASCII字符可以以\x##形式的十六进制表示&lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;\x41&#39;; // 完全等同于 &#39;A&#39;&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;用\u####表示一个Unicode字符&lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;\u4e2d\u6587&#39;; // 完全等同于 &#39;中文&#39;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;多行字符串，ES6新增用` … `表示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`这是一个
多行
字符串`;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;用+号连接字符串,ES6新增了一种模板字符串&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var name = &#39;小明&#39;;
var age = 20;
var message = &#39;你好, &#39; + name + &#39;, 你今年&#39; + age + &#39;岁了!&#39;;
alert(message);

ES6新模板字符串
var message = `你好, ${name}, 你今年${age}岁了!`;
alert(message);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var s = &#39;Hello, world!&#39;;

s[0]; // &#39;H&#39;
s[6]; // &#39; &#39;
s[7]; // &#39;w&#39;
s[12]; // &#39;!&#39;
s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaScript为字符串提供了一些常用方法，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;布尔值&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个布尔值只有true、false两种值，要么是true，要么是false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;true; // 这是一个true值
false; // 这是一个false值
2 &amp;gt; 1; // 这是一个true值
2 &amp;gt;= 3; // 这是一个false值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：JavaScript允许对任意数据类型做比较&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己&lt;code class=&quot;highlighter-rouge&quot;&gt;NaN === NaN; // false&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;数组&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript的数组可以包括任意数据类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[1, 2, 3.14, &#39;Hello&#39;, null, true];
new Array(1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意，直接给Array的length赋一个新的值会导致Array大小的变化&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Array通过indexOf()来搜索一个指定的元素的位置
slice()截取Array的部分元素，然后返回一个新的Array&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
arr.slice(3); // 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉&lt;/p&gt;

  &lt;p&gt;unshift()方法往Array的头部添加若干元素，shift()方法把Array的第一个元素删掉&lt;/p&gt;

  &lt;p&gt;sort()对当前Array进行排序&lt;/p&gt;

  &lt;p&gt;reverse()把整个Array反转&lt;/p&gt;

  &lt;p&gt;splice()方法修改Array，从指定的索引开始删除若干元素，然后再从该位置添加若干元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); // 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]
// 只删除,不添加:
arr.splice(2, 2); // [&#39;Google&#39;, &#39;Facebook&#39;]
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]
// 只添加,不删除:
arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); // 返回[],因为没有删除任何元素
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array，它可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里
join()方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3];
arr.join(&#39;-&#39;); // &#39;A-B-C-1-2-3&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;对象&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript的对象是一组由键-值组成的无序集合,键都是字符串类型，值可以是任意数据类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var person = {
    name: &#39;Bob&#39;,
    age: 20,
    tags: [&#39;js&#39;, &#39;web&#39;, &#39;mobile&#39;],
    city: &#39;Beijing&#39;,
    hasCar: true,
    zipcode: null
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var xiaoming = {
    name: &#39;小明&#39;
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming[&#39;name&#39;]; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果要检测对象是否拥有某一属性，包括继承得到的，可以用in操作符
要判断一个属性是否是自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var xiaoming = {
    name: &#39;小明&#39;
};
&#39;name&#39; in xiaoming; // true
&#39;toString&#39; in xiaoming; // true
xiaoming.hasOwnProperty(&#39;name&#39;); // true
xiaoming.hasOwnProperty(&#39;toString&#39;); // false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;map&quot;&gt;Map&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript的对象有个问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是合理的。为了解决这个问题，最新的ES6规范引入了新的数据类型Map。&lt;/p&gt;

  &lt;p&gt;Map是一组键值对的结构，具有极快的查找速度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var m = new Map(); // 空Map
m.set(&#39;Adam&#39;, 67); // 添加新的key-value
m.set(&#39;Bob&#39;, 59);
m.has(&#39;Adam&#39;); // 是否存在key &#39;Adam&#39;: true
m.get(&#39;Adam&#39;); // 67
m.delete(&#39;Adam&#39;); // 删除key &#39;Adam&#39;
m.get(&#39;Adam&#39;); // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;set&quot;&gt;Set&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Set也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。&lt;/p&gt;

  &lt;p&gt;重复元素在Set中自动被过滤&lt;/p&gt;

  &lt;p&gt;通过add(key)方法添加元素到Set中&lt;/p&gt;

  &lt;p&gt;通过delete(key)方法删除元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var s = new Set([1, 2, 3, 3, &#39;3&#39;]);
s; // Set {1, 2, 3, &quot;3&quot;}
s.add(4);// 添加元素4
s.delete(3);// 添加元素3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-7&quot;&gt;变量&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a; // 申明了变量a，此时a的值为undefined
var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
var s_007 = &#39;007&#39;; // s_007是一个字符串
var Answer = true; // Answer是一个布尔值true
var t = null; // t的值是null
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary>1995年，网景公司的Brendan Eich在两周之内设计出了JavaScript语言</summary></entry><entry><title>2017年开始强制https的问题</title><link href="/ios/ATS&https/" rel="alternate" type="text/html" title="2017年开始强制https的问题" /><published>2016-10-04T00:00:00+08:00</published><updated>2016-10-04T00:00:00+08:00</updated><id>/ios/ATS&amp;https</id><content type="html" xml:base="/ios/ATS&amp;https/">&lt;blockquote&gt;
  &lt;p&gt;iOS9 中默认非HTTPS的协议是被禁止的，我们为了能正常发起http请求，在info.plist文件中添加AppTransportSecuritySettings字典，将NSAllowsArbitraryLoads设置为YES来禁止ATS。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;iOS10 从2017年1月1日起苹果提出所有新提交的App默认不允许使用NSAllowsArbitraryLoads来绕过ATS的限制，也就是说强制我们用HTTPS，否则我们提交App可能会被拒绝。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;通过NSExceptionDomains设置白名单的方式来针对特定的域名开放HTTP内容来通过审核。可以简单理解成，把不支持https协议的接口添加到白名单。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;操作步骤&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;在项目info.plist中添加一个Key：App Transport Security Settings，类型为Dictionary&lt;/li&gt;
  &lt;li&gt;在第一步添加的字典内添加一个Key: Exception Domains，类型为Dictionary&lt;/li&gt;
  &lt;li&gt;在Exception Domains内添加要支持的域，其中域作为Key，类型为Dictionary&lt;/li&gt;
  &lt;li&gt;每个域下面需要设置3个属性：类型为Boolean&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSIncludesSubdomains  YES
NSExceptionRequiresForwardSecrecy  NO
NSExceptionAllowsInsecureHTTPLoads  YES
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160920163718539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;应用场景&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;第三方不支持https请求的接口&lt;/li&gt;
  &lt;li&gt;不支持https协议的图片地址&lt;/li&gt;
  &lt;li&gt;不支持https协议的h5网址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;玩的开心……&lt;/p&gt;</content><summary>2017年开始强制https的问题.</summary></entry><entry><title>金额相关精度问题总结</title><link href="/ios/%E9%87%91%E9%A2%9D%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/" rel="alternate" type="text/html" title="金额相关精度问题总结" /><published>2016-02-03T00:00:00+08:00</published><updated>2016-02-03T00:00:00+08:00</updated><id>/ios/金额精度计算</id><content type="html" xml:base="/ios/%E9%87%91%E9%A2%9D%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/">&lt;p&gt;最近项目中遇到金额计算，CGFloat类型金额计算的过程中，让我吃了不少苦头，先来看下面几行代码:&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;示例代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    CGFloat var1 = 120.66;
    CGFloat var2 = 120.66;
    
    CGFloat var3 = [@&quot;120.66&quot; floatValue];
    CGFloat var4 = [@&quot;120.66&quot; floatValue];
    
    CGFloat var5 = 120.67 - 0.01;
    
    CGFloat var6 = [@&quot;120.67&quot; floatValue] - 0.01;
    
    bool flag1 = var1 == var2;
    bool flag2 = var3 == var4;
    bool flag3 = var3 == var5;
    bool flag4 = var5 == var6;
    bool flag5 = var3 == var6;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;略去猜答案的过程，直接看结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s27.postimg.org/5m7cgftvn/Wechat_IMG1.jpg&quot; alt=&quot;图一&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;现象总结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;var1 和var2相等&lt;/li&gt;
  &lt;li&gt;var3 和var4相等&lt;/li&gt;
  &lt;li&gt;NSString 的 floatValue 会让CGFloat 的精度增加&lt;/li&gt;
  &lt;li&gt;精度确定的float类型做运算，精度确定 var5 = 120.66&lt;/li&gt;
  &lt;li&gt;不同精度的float类型做运算，精度会丢失 var6 = 120.65999816894531&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;鉴于CGFloat在处理金额过程中会遇到精度问题，iOS中提供了NSDecimalNumber类来处理精度问题,如果要四舍五入的话还要使用另一个类 NSDecimalNumberHandler&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;nsdecimalnumber&quot;&gt;NSDecimalNumber类&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
     讲述下参数的含义:
     RoundingMode: 简单讲就是你要四舍五入操作的标准.
typedef NS_ENUM(NSUInteger, NSRoundingMode) {
    NSRoundPlain,   // 精度位后四舍五入
    NSRoundDown,    // 精度位后舍去
    NSRoundUp,      // 精度位后入上去
    NSRoundBankers  // 精度位后的数值等于5时，分两种情况：5后面还有其他数字（非0），则进位后舍去；若5后面是0（即5是最后一位），则根据5前一位数的奇偶性来判断是否需要进位，奇数进位，偶数舍去。
};		
    // Rounding policies :
	// Original
	//    value 1.2  1.21  1.25  1.35  1.27
	// Plain    1.2  1.2   1.3   1.4   1.3
	// Down     1.2  1.2   1.2   1.3   1.2
	// Up       1.2  1.3   1.3   1.4   1.3
	// Bankers  1.2  1.2   1.2   1.4   1.3

     scale : 需要保留的精度。
     raiseOnExactness : 为YES时在处理精确时如果有错误，就会抛出异常。
     raiseOnOverflow  : YES时在计算精度向上溢出时会抛出异常，否则返回。
     raiseOnUnderflow : YES时在计算精度向下溢出时会抛出异常，否则返回.
     raiseOnDivideByZero : YES时。当除以0时会抛出异常，否则返回。
     */
     
     保留2位小数
NSDecimalNumberHandler *roundUp = [NSDecimalNumberHandler decimalNumberHandlerWithRoundingMode:NSRoundPlain
                                                                                            scale:2
                                                                                 raiseOnExactness:NO
                                                                                  raiseOnOverflow:NO
                                                                                 raiseOnUnderflow:NO
                                                                              raiseOnDivideByZero:YES];                                                                                                                                                 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;计算金额并四舍五入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSDecimalNumber *originMoney = [NSDecimalNumber decimalNumberWithString:num];//通过字符串计算金额
NSDecimalNumber *roundMoney = [subtotal decimalNumberByRoundingAccordingToBehavior:roundUp];//按照设定的规则计算出金额
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;金额计算实例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSDecimalNumber *varDecimal1 = [NSDecimalNumber decimalNumberWithString:@&quot;120.661&quot;];//120.661
NSDecimalNumber *varDecimal2 = [NSDecimalNumber decimalNumberWithString:@&quot;120.670&quot;];//120.670

//加
[varDecimal1 decimalNumberByAdding:varDecimal2];

//减
NSDecimalNumber *varDecimal3 = [[varDecimal2 decimalNumberBySubtracting:varDecimal1] decimalNumberByRoundingAccordingToBehavior:roundUp];//0.01

//乘
[varDecimal1 decimalNumberByMultiplyingBy:[NSDecimalNumber decimalNumberWithString:@&quot;0.005&quot;]];

//除
[varDecimal1 decimalNumberByDividingBy:varDecimal2];

//比较
[varDecimal1 compare:varDecimal2] == NSOrderedAscending //varDecimal1小于varDecimal2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;总结&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;金额相关，后台要传字符串到前台&lt;/li&gt;
  &lt;li&gt;计算过程中要用NSDecimalNumber来防止计算过程中出现精度错误&lt;/li&gt;
  &lt;li&gt;[@”120.67” floatValue] - 0.01 不等于120.66&lt;/li&gt;
&lt;/ol&gt;</content><summary>最近项目中遇到金额计算，CGFloat类型金额计算的过程中，让我吃了不少苦头</summary></entry><entry><title>JSPatch 从入门到放弃</title><link href="/ios/JSPatch%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/" rel="alternate" type="text/html" title="JSPatch 从入门到放弃" /><published>2015-11-06T00:00:00+08:00</published><updated>2015-11-06T00:00:00+08:00</updated><id>/ios/JSPatch从入门到放弃</id><content type="html" xml:base="/ios/JSPatch%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/">&lt;h2 id=&quot;jspatch-&quot;&gt;JSPatch 是什么&lt;/h2&gt;

&lt;p&gt;JSPatch 是一个开源项目(&lt;a href=&quot;https://github.com/bang590/JSPatch&quot;&gt;Github链接&lt;/a&gt;)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。&lt;/p&gt;

&lt;h2 id=&quot;jspatch&quot;&gt;JSPatch平台又是什么鬼&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;JSPatch需要你自己搞一个服务器管理、下发脚本，还要处理安全问题，高并发问题，烦死你。JSPatch平台封装了SDK，你只需要继承SDK就可以省去一堆的麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JSPatch 需要使用者有一个后台可以下发和管理脚本，并且需要处理传输安全等部署工作，JSPatch 平台帮你做了这些事，提供了脚本后台托管，版本管理，保证传输安全等功能，让你无需搭建一个后台，无需关心部署操作，只需引入一个 SDK 即可立即使用 JSPatch。&lt;/p&gt;

&lt;p&gt;JSPatch 平台的 SDK 在核心代码的基础上增加了向平台请求脚本/传输解密/版本管理等功能，只用于这个平台。&lt;/p&gt;

&lt;p&gt;通过 JSPatch 平台上传的脚本文件都会保存在七牛云存储上，客户端 APP 只跟七牛服务器通讯，支持高并发，CDN分布全国，速度和稳定性有保证。&lt;/p&gt;

&lt;h2 id=&quot;sdk&quot;&gt;SDK接入&lt;/h2&gt;

&lt;p&gt;这种问题不要问我，注册一个账号，建一个app获取到appid，然后接入SDK完事儿。至于你是用cocoapods还是手动接入，全凭个人喜好。&lt;a href=&quot;http://jspatch.com/Docs/SDK&quot;&gt;SDK接入&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;api&quot;&gt;API主要方法&lt;/h2&gt;

&lt;h4 id=&quot;startwithappkey&quot;&gt;+startWithAppKey:&lt;/h4&gt;

&lt;p&gt;传入在平台申请的 appKey，启动 JSPatch SDK。在&lt;code class=&quot;highlighter-rouge&quot;&gt;-application:didFinishLaunchingWithOptions:&lt;/code&gt;开头初始化第三方库的时候一并调用初始化。&lt;/p&gt;

&lt;h4 id=&quot;sync&quot;&gt;+sync&lt;/h4&gt;

&lt;p&gt;与 JSPatch 平台后台同步，询问是否有 patch 更新，如果有更新会自动下载并执行。
&amp;gt;每调用一次 +sync 就会请求一次后台，如果app启动的时候检查一次就OK的话就在&lt;code class=&quot;highlighter-rouge&quot;&gt;-application:didFinishLaunchingWithOptions:&lt;/code&gt;调用一次。
&amp;gt;
&amp;gt;如果实时性要求高，就在&lt;code class=&quot;highlighter-rouge&quot;&gt;-applicationDidBecomeActive:&lt;/code&gt;的时候调用。&lt;/p&gt;

&lt;h4 id=&quot;setuplogger&quot;&gt;+setupLogger:&lt;/h4&gt;

&lt;p&gt;SDK打一些请求和执行的log，默认是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog()&lt;/code&gt;输出，如果app有自己的日志系统，并且希望自己的日志系统拿到这些log，则在+startWithAppKey之前调用这个方法。&lt;/p&gt;

&lt;h4 id=&quot;testscriptinbundle&quot;&gt;+testScriptInBundle&lt;/h4&gt;

&lt;p&gt;写好的脚本上线前总要测试一下吧，就是用这个方法。需要把main.js文件拖到项目中，并且不要调用+startWithAppKey:方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意！！！：测试完成一定要删除main.js,血淋淋的教训是，如果不删除，线上的脚本down下来之后，无法确定会执行哪个main.js,莫名其妙的问题，并且很难找到。切记切记&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;setupcallback&quot;&gt;+setupCallback:&lt;/h4&gt;

&lt;p&gt;JSPatch 执行过程中的事件回调，在以下事件发生时会调用传入的 block：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, JPCallbackType){
    JPCallbackTypeUnknow        = 0,
    JPCallbackTypeRunScript     = 1,    //执行脚本
    JPCallbackTypeUpdate        = 2,    //脚本有更新
    JPCallbackTypeUpdateDone    = 3,    //已拉取新脚本
    JPCallbackTypeCondition     = 4,    //条件下发
    JPCallbackTypeGray          = 5,    //灰度下发
};

例如
[JSPatch setupCallback:^(JPCallbackType type, NSDictionary *data, NSError *error) {
    switch (type) {
        case JPCallbackTypeUpdate: {
            NSLog(@&quot;updated %@ %@&quot;, data, error);
            break;
        }
        case JPCallbackTypeRunScript: {
            NSLog(@&quot;run script %@ %@&quot;, data, error);
            break;
        }
        default:
            break;
    }
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;setupuserdata&quot;&gt;+setupUserData：&lt;/h4&gt;

&lt;p&gt;定义用户属性，在&lt;code class=&quot;highlighter-rouge&quot;&gt;+sync:&lt;/code&gt;之前调用，用于条件下发，可以用来做AB测试。什么是AB测试？自己去Google啊…&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[JSPatch setupUserData:@{
    @&quot;userId&quot;: user.userId, 
    @&quot;location&quot;: user.location,
    @&quot;gender&quot;:user.gender,
    @&quot;age&quot;:user.age
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://s29.postimg.org/annnszag7/7_D77_D381_B652_457_C_A742_2232_F8_F3_DF1_D.jpg&quot; alt=&quot;条件下发&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发布补丁的时候选择条件下发，写入相应的条件就可以实现条件下发。例如图中性别是女，年龄小于35岁的用户显示特定的内容。还可以选择手机系统的版本。&lt;/p&gt;

&lt;h4 id=&quot;setupdevelopment&quot;&gt;+setupDevelopment&lt;/h4&gt;

&lt;p&gt;开发者预览模式，可以在 debug 模式下测试补丁效果。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[JSPatch startAppWithKey:@&quot;&quot;];
#ifdef DEBUG
[JSPatch setupDevelopment];
#endif
[JSPatch sync];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;灰度下发&lt;/h2&gt;

&lt;p&gt;这个功能太实用了，选择灰度下发可以按照&lt;strong&gt;比例灰度&lt;/strong&gt;和&lt;strong&gt;人数灰度&lt;/strong&gt;下发。比例灰度例如随机挑选 30% 的设备生效；人数灰度比如只安装1000台设备。应用场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先下发一批看看效果，如果OK就全量下发&lt;/li&gt;
  &lt;li&gt;只对部分用户下发，显示特定的效果（和条件下发类似）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实战&lt;/h2&gt;

&lt;p&gt;扯了这么多终于到实战了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;背景：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;项目已经集成了SDK&lt;/li&gt;
  &lt;li&gt;注册过了平台账号&lt;/li&gt;
  &lt;li&gt;已经注册了APP获得了appkey&lt;/li&gt;
  &lt;li&gt;已经上线了集成过JSPatch SDK的app&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;这个上线的版本出现了大量的crash，crash率很高，不马上解决，老板就会马上解决你…&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线上的代码是这样的,数组访问越界了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DSHomeViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;didSelectRowAtIndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSIndexPath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可能会超出数组范围导致crash
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;DSGoodsViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;controller&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DSGoodsViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;navigationController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pushViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;修改源代码&lt;/h3&gt;

&lt;p&gt;修改后的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DSHomeViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;didSelectRowAtIndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSIndexPath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;DSGoodsViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;controller&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DSGoodsViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;navigationController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pushViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;编写补丁脚本&lt;/h3&gt;

&lt;p&gt;打开&lt;a href=&quot;http://jspatch.com/Tools/convertor&quot;&gt;JSPatch代码转换器&lt;/a&gt;，原生代码转化为JS代码
&lt;img src=&quot;https://s23.postimg.org/6yuw0er9n/Wechat_IMG1.jpg&quot; alt=&quot;转化器&quot; /&gt;&lt;/p&gt;

&lt;p&gt;转化成功了，但是要数组，需要修改一下。&lt;a href=&quot;https://github.com/bang590/JSPatch/wiki/JSPatch-常见问题#字符串--数组--字典-操作问题&quot;&gt;常见问题&lt;/a&gt; 修改之后的脚本,为了能够知道脚本运行，第一行加上log&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(&#39;JSPatch Run Success&#39;);
require(&quot;DSGoodsViewController&quot;);

defineClass(&quot;DSHomeViewController&quot;, {
    tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
        var row = indexPath.row();
        if (self.dataSource().length() &amp;gt; row) {
            var content = self.dataSource()[row];
            var controller = DSGoodsViewController.alloc().initWithContent(content);
            self.navigationController().pushViewController(controller);
        }
    }
}, {});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;测试脚本&lt;/h3&gt;

&lt;p&gt;写好之后的脚本存为main.js放到项目中，在&lt;code class=&quot;highlighter-rouge&quot;&gt;-application:didFinishLaunchingWithOptions:&lt;/code&gt;方法中打开测试&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
	 //[JSPatch startWithAppKey:myAPPKey];
    //[JSPatch sync];
    [JSPatch testScriptInBundle];
    ….
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;编译运行会看到控制台log输出&lt;code class=&quot;highlighter-rouge&quot;&gt;JSPatch Run Success&lt;/code&gt; 然后……怎么能少了调试呢&lt;/p&gt;

&lt;h3 id=&quot;safari&quot;&gt;在Safari中断点调试&lt;/h3&gt;

&lt;h5 id=&quot;safari-&quot;&gt;开启 Safari 调试菜单&lt;/h5&gt;

&lt;p&gt;Safari -&amp;gt; 偏好设置 -&amp;gt; 高级 -&amp;gt; 勾选[在菜单栏中显示“开发”菜单]&lt;/p&gt;

&lt;h5 id=&quot;app&quot;&gt;启动app进行调试&lt;/h5&gt;

&lt;p&gt;启动APP -&amp;gt; Safari -&amp;gt; 开发 -&amp;gt; 选择你的机器 -&amp;gt; JSContext&lt;/p&gt;

&lt;p&gt;在 iOS8 下，JSPatch 支持使用 Safari 自带的调试工具对 JS 脚本进行断点调试，界面大致长这样
&lt;img src=&quot;https://github.com/bang590/JSPatch/wiki/images/debuggerCN.png&quot; alt=&quot;JS调试器&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;上传脚本&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在平台上新建一个线上的版本&lt;/li&gt;
  &lt;li&gt;把调试通过的脚本main.js上传到这个线上的版本&lt;/li&gt;
  &lt;li&gt;选择全量下发（因为要搞定crash）&lt;/li&gt;
  &lt;li&gt;删除本地的main.js&lt;/li&gt;
  &lt;li&gt;好了，等着下发之后crash率降下来，饭碗保住了&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-7&quot;&gt;常见的问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;不能用 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog(&#39;xx&#39;)&lt;/code&gt;，应该用 &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log(&#39;xx&#39;)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;get property 记得加括号，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.navigationItem()&lt;/code&gt;，而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.navigationItem&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;私有成员变量要用 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.valueForKey()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.setValue_forKey()&lt;/code&gt; 接口存取&lt;/li&gt;
  &lt;li&gt;block 里不能直接使用 self,应该在block外定义var myself = self;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他更多请参见 wiki 的 &lt;a href=&quot;https://github.com/bang590/JSPatch/wiki/JSPatch-基础用法&quot;&gt;基础用法&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/bang590/JSPatch/wiki/JSPatch-常见问题&quot;&gt;常见问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;未完待续。。。&lt;/p&gt;</content><summary>动态修复bug利器，岂能不知道，Let&#39;s go</summary></entry><entry><title>常用基础命令合集</title><link href="/git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BA%8C/" rel="alternate" type="text/html" title="常用基础命令合集" /><published>2015-06-08T00:00:00+08:00</published><updated>2015-06-08T00:00:00+08:00</updated><id>/git/Git常用命令二</id><content type="html" xml:base="/git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BA%8C/">&lt;p&gt;所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化。&lt;/p&gt;

&lt;p&gt;不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。&lt;/p&gt;

&lt;h3 id=&quot;git-&quot;&gt;Git 常用基础命令合集&lt;/h3&gt;

&lt;h5 id=&quot;section&quot;&gt;创建&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git init 创建空的repository
git add fileName 添加修改的文件，把文件修改添加到暂存区
git commit -m &#39;提交的消息&#39; 把暂存区的所有内容提交到当前分支
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-1&quot;&gt;分支&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git branch 查看分支
git branch branchName 创建分支
git checkout branchName 切换到branchName分支
git checkout -b branchName  创建并切换到branchName分支
git checkout -b branch-name origin/branch-name 在本地创建和远程分支对应的分支
git merge branchName 把branchName分支合并到当前分支
git branch -d branchName 删除branchName分支，注意不要在branchName分支上做这个操作
git branch --set-upstream branch-name origin/branch-name 建立本地分支和远程分支的关联

git branch -D branchName 强制删除本地分支
git push origin :branchName 删除远程分支
git push origin --delete branchName 删除远程分支(Git1.7.0可用)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-2&quot;&gt;查看修改&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git status 查看当前状态，有哪些改动
git diff fileName 查看文件修改的内容
git diff HEAD -- fileName 查看文件fileName工作区和版本库最新版本的区别
git diff commitId1 commitId2 查看两次提交的区别
git diff commitId1:fileName commitId2:fileName 查看两次提交的文件的区别
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-3&quot;&gt;撤销修改&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git reset --mixed 
git reset --hard commit_id 回滚到commit_id的commit
git checkout -- fileName 撤销fileName文件在工作区的修改，注意--不要丢掉，回到添加到暂存区后的状态
git reset HEAD fileName 把暂存区的fileName的修改撤销掉
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-4&quot;&gt;查看提交历史&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log 查看提交历史
git log --pretty=oneline 查看log，一行一行地显示
git reflog 查看git操作记录
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;ssh-key&quot;&gt;创建ssh key&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen -t rsa -C &quot;youremail@example.com&quot; //生成一对公钥id_rsa.pub 私钥id_rsa
cat ~/.ssh/id_rsa.pub //查看生成的公钥
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-5&quot;&gt;远程仓库&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快
git remote add origin remoteUrl 远程建了一个空仓库，连接本地到远程(remoteUrl是远程仓库的地址)
git push origin master 把本地分支master 推送到远程
git clone remoteUrl 克隆一个远程已存在的仓库到本地(remoteUrl是远程仓库的地址)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-6&quot;&gt;标签管理&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git tag tagName 为当前分支打名字为tagName的标签，默认标签是打在最新提交的commit上
git tag tagName commit_id 在commit_id上打tag，适用于忘记打tag的情况
git tag -a tagName -m &quot;blablabla...&quot; 打标签指定标签信息
git show tagName 查看tag的说明
git tag -d tagName 删除本地标签tagName
git push origin tagName 把标签推送到远程
git push origin --tags 推送所有标签到远程
git push origin :refs/tags/tagName 删除远程的标签tagName
git tag --list 查看所有tag
git checkout -b tagBranch tagName 检出tag代码

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;git--1&quot;&gt;Git 命令进阶&lt;/h3&gt;

&lt;h5 id=&quot;message&quot;&gt;修改提交message&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#Commit has not been pushed online
git commit --amend

#Amending the message of the most recently pushed commit
git commit --amend
git push --force &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;git-rebase&quot;&gt;Git rebase&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#rebase 远程分支
git fetch
git rebase origin
处理conflicts
git add .
git rebase --continue
git push origin master

#rebase 本地分支
git rebase branchName
处理conflicts
git add .
git rebase --continue
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-7&quot;&gt;多行注释&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit -m &#39;
1.one
2.two
&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-8&quot;&gt;查看本地分支跟踪的远程分支&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git branch -vv
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-9&quot;&gt;切换跟踪的分支&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote rm origin
git remote add origin git@git.nonobank.com:lejiangkai/MXD.git
git push -u origin feature5.5.4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;stash&quot;&gt;stash用法&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash
git stash pop
git list
git stash apply stash@{3}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-10&quot;&gt;合并某个分支的单个文件&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout targetbranch
git checkout needMergeBranch -- needMergeFileName

如： 分支test上有一个文件A，你在test1分支上， 此时如果想用test分支上的A文件替换test1分支上的文件的话，可以使用
git checkout test1
然后
git checkout test -- A
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。</summary></entry><entry><title>iOS Development Tips</title><link href="/ios/iOSDevelopTips/" rel="alternate" type="text/html" title="iOS Development Tips" /><published>2014-08-05T00:00:00+08:00</published><updated>2014-08-05T00:00:00+08:00</updated><id>/ios/iOSDevelopTips</id><content type="html" xml:base="/ios/iOSDevelopTips/">&lt;h4 id=&quot;section&quot;&gt;数组拼接字符串&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *arr = [NSArray arrayWithObjects:@&quot;I&quot;, @&quot;love&quot;, @&quot;you&quot;, nil];
NSLog(@&quot;%@&quot;,[arr componentsJoinedByString:@&quot;&quot;]);//打印Iloveyou
NSLog(@&quot;%@&quot;,[arr componentsJoinedByString:@&quot; &quot;]);//打印I love you
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- (NSArray&amp;lt;NSString *&amp;gt; *)componentsSeparatedByCharactersInSet:(NSCharacterSet *)separator&lt;/code&gt;方法的而作用是通过set来进行分割字符串，返回分割后的数组。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456&quot;];
NSString *nam = @&quot;1g2h45j3d688&quot;;
NSLog(@&quot;%@&quot;,[nam componentsSeparatedByCharactersInSet:set]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;输入框只能输入字母和数字&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {
    NSCharacterSet *charSet = [[NSCharacterSet characterSetWithCharactersInString:@&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;] invertedSet];
    NSString *filteredStr = [[string componentsSeparatedByCharactersInSet:charSet] componentsJoinedByString:@&quot;&quot;];
    if ([string isEqualToString:filteredStr]) {
        return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;限制输入框输入长度&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define MAXLENGTH 10

- (BOOL)textField:(UITextField *) textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {

    NSUInteger oldLength = [textField.text length];
    NSUInteger replacementLength = [string length];
    NSUInteger rangeLength = range.length;

    NSUInteger newLength = oldLength - rangeLength + replacementLength;

    BOOL returnKey = [string rangeOfString: @&quot;\n&quot;].location != NSNotFound;

    return newLength &amp;lt;= MAXLENGTH || returnKey;
}

// 对于能输入中文的输入框 还要增加方法
- (void)textFieldDidChange:(UITextField *)textField
{
    if (textField == self.titleField) {
        if (textField.text.length &amp;gt; MAXLENGTH) {
            textField.text = [textField.text substringToIndex:MAXLENGTH];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;金额输入框 只能输入一个小数点，小数点后只能输入两位&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{
    //控制输入框输入长度
    NSInteger maxLength = 11;
    NSUInteger oldLength = [textField.text length];
    NSUInteger replacementLength = [string length];
    NSUInteger rangeLength = range.length;
    NSUInteger newLength = oldLength - rangeLength + replacementLength;
    BOOL returnKey = [string rangeOfString: @&quot;\n&quot;].location != NSNotFound;
    if (range.location==0 &amp;amp;&amp;amp; [string isEqualToString:@&quot;.&quot;])
    {
        return NO;
    }
    if ([string isEqualToString:@&quot;&quot;]) {
        return YES;
    }
    NSString *checkStr = [textField.text stringByReplacingCharactersInRange:range withString:string];
    //正则表达式 数字或小数点后两位
    NSString *regex = @&quot;^\\-?([1-9]\\d*|0)(\\.\\d{0,2})?$&quot;;
    return (newLength &amp;lt;= maxLength || returnKey) &amp;amp;&amp;amp; [self isValid:checkStr withRegex:regex];
}

//检测改变过的文本是否匹配正则表达式，如果匹配表示可以键入，否则不能键入
- (BOOL) isValid:(NSString*)checkStr withRegex:(NSString*)regex{
    NSPredicate *predicte = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,regex];
    return [predicte evaluateWithObject:checkStr];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;沙盒机制&lt;/h4&gt;

&lt;p&gt;沙盒根目录结构：Documents、Library、temp。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Documents：用于存储用户数据，iTunes备份和恢复的时候会包括此目录，所以，苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Library：包含两个子目录：Caches和Preferences。Caches用来存放用户需要换成的文件。Preferences是APP的偏好设置，可以通过NSUserDefaults来读取和设置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tmp：用于存放临时文件，这个可以放一些当APP退出后不再需要的文件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-5&quot;&gt;获取键盘高度&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver:self
                                     selector:@selector(keyboardWasShown:)
                                         name:UIKeyboardDidShowNotification
                                       object:nil];

- (void)keyboardWasShown:(NSNotification *)notification
{

// Get the size of the keyboard.
CGSize keyboardSize = [[[notification userInfo] objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue].size;

//Given size may not account for screen rotation
int height = MIN(keyboardSize.height,keyboardSize.width);
int width = MAX(keyboardSize.height,keyboardSize.width);

//your other code here..........
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;uilabel-linebreakmode&quot;&gt;UILabel lineBreakMode&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lineBreakMode：设置标签文字过长时的显示方式。   
label.lineBreakMode = NSLineBreakByCharWrapping;    //以字符为显示单位显示，后面部分省略不显示。   
label.lineBreakMode = NSLineBreakByClipping;        //剪切与文本宽度相同的内容长度，后半部分被删除。   
label.lineBreakMode = NSLineBreakByTruncatingHead;  //前面部分文字以……方式省略，显示尾部文字内容。   
label.lineBreakMode = NSLineBreakByTruncatingMiddle;    //中间的内容以……方式省略，显示头尾的文字内容。   
label.lineBreakMode = NSLineBreakByTruncatingTail;  //结尾部分的内容以……方式省略，显示头的文字内容。   
label.lineBreakMode = NSLineBreakByWordWrapping;    //以单词为显示单位显示，后面部分省略不显示。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;uibarbuttonitem-&quot;&gt;UIBarButtonItem 左右距离&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//左右边距调整增加空的按钮即可
UIBarButtonItem *rightBtn = [[UIBarButtonItem alloc] init];
UIButton *rgbtn = [[UIButton alloc] initWithFrame:CGRectMake(80, 10, 80, 13)];
[rgbtn setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
[rgbtn setTitle:btnTitle forState:UIControlStateNormal];
rgbtn.titleLabel.font = [UIFont systemFontOfSize:BTN_FONT];
[rgbtn addTarget:self action:@selector(switchTrafic) forControlEvents:UIControlEventTouchUpInside];
rightBtn.customView = rgbtn;
UIBarButtonItem *negativeSpacer = [[UIBarButtonItem alloc]
                                       initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace
                                       target:nil action:nil];
negativeSpacer.width = -18;
self.navigationItem.rightBarButtonItems = [NSArray arrayWithObjects:negativeSpacer,rightBtn, nil];
[negativeSpacer release];
[rightBtn release];
[rgbtn release];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;uisearchbar&quot;&gt;UISearchBar的背景设置为透明&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self.mySearchBar setBackgroundColor:[UIColor clearColor]];
[self.mySearchBar setBackgroundImage:[UIImage new]];
[self.mySearchBar setTranslucent:YES];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;根据颜色生成图片&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (UIImage *) createImageWithColor: (UIColor *) color{
    CGRect rect=CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetFillColorWithColor(context, [color CGColor]);
    CGContextFillRect(context, rect);

    UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return theImage;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;dyld-library-not-loaded-rpathxctestframeworkxctest&quot;&gt;dyld: Library not loaded: @rpath/XCTest.framework/XCTest&lt;/h4&gt;

&lt;p&gt;解决办法：工程－&amp;gt;targets－&amp;gt;Bulid Phases－&amp;gt;complie Sources 搜索一下是否有test，有的话，删除一下即可。&lt;/p&gt;

&lt;h4 id=&quot;appstore&quot;&gt;版本更新跳转到AppStore显示“打开”而不是“更新”的问题&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;原因：AppStore有缓存，导致即使不是最新版app也显示”打开“，不显示”更新“&lt;/p&gt;

  &lt;p&gt;解决方法：杀死AppStore，重新打开即可&lt;/p&gt;
&lt;/blockquote&gt;</content><summary>DevelopTips</summary></entry><entry><title>多个git账号配置</title><link href="/git/%E5%A4%9A%E4%B8%AAgit%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="多个git账号配置" /><published>2014-01-11T00:00:00+08:00</published><updated>2014-01-11T00:00:00+08:00</updated><id>/git/多个git账号配置</id><content type="html" xml:base="/git/%E5%A4%9A%E4%B8%AAgit%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/">&lt;p&gt;一般情况下，一台电脑会连接多个git服务器，比如公司的一台，oschina一台，github一台，三个账号都要用，废话少说，直接上干货。&lt;/p&gt;

&lt;h3 id=&quot;ssh-keygenidrsagithubidrsagithubpub&quot;&gt;1.用ssh-keygen命令生成一组新的id_rsa_github和id_rsa_github.pub&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen -t rsa -C &quot;new email&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;平时我们都是直接回车，默认生成id_rsa和id_rsa.pub。这里特别需要注意，出现提示输入文件名的时候要输入与默认配置不一样的文件名，比如：  id_rsa_github&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;sshconfig&quot;&gt;2.配置~/.ssh/config文件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host git.oschina.net
   User Kevin
   Hostname git.oschina.net 
   IdentityFile ~/.ssh/id_rsa_oschina

Host github.com
   User Kevin
   Hostname github.com 
   IdentityFile ~/.ssh/id_rsa_github
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;IdentityFile告诉SSH连接去读取哪个私钥&lt;/p&gt;

&lt;h3 id=&quot;ssh-agentssh&quot;&gt;3.执行ssh-agent让ssh识别新的私钥&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-add ~/.ssh/id_rsa_github
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;4.注意事项&lt;/h3&gt;

&lt;p&gt;多个账号同时使用时，要需要设置的全局用户名和用户邮箱，在每个repo目录下单独设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//取消全局设置
git config --global --unset user.name 取消全局设置
git config --global --unset user.email 取消全局设置

//单独设置
git config user.name &quot;newname&quot;
git config user.email &quot;newemail&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary>一般情况下，一台电脑会连接多个git服务器，比如公司的一台，oschina一台，github一台，三个账号都要用，废话少说，直接上干货</summary></entry></feed>
